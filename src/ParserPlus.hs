{- | Utilities for working with parsing, e.g., `Text.Read`, or `Text.Parsec`. -}
module ParserPlus
  ( betweenCs, boundedDoubledChars, braces, brackets, caseInsensitiveChar
  , caseInsensitiveString, commaList, commaSet, convertParser, convertReadParser
  , counts, digits, doubledChar, doubledChars, dQuotedString, many1choice
  , nDecimal, nDecimalDigits, nDecimalDigits', ndigits, ndigitsPadR, nl, parens
  , parse1_2, parse1_2digits, parseBackslashedChar, parseDecimal2_1
  , parseFloat2_1, parseMicros, parseMillis, sepByNE, stringMaybeDQuoted, tries
  , uniquePrefix, utf8BOM, whitespaces

  , tests
  )
where

import Prelude  ( (-), Double, Float, Num, fromIntegral, Int )

-- base --------------------------------

import qualified Data.List.NonEmpty  as  NonEmptyList

import Control.Applicative  ( Alternative, many, optional, pure )
import Control.Monad        ( Monad, liftM2, return, sequence )
import Control.Monad.Fail   ( MonadFail, fail )
import Data.Bifunctor       ( first )
import Data.Char            ( toLower, toUpper )
import Data.Either          ( either )
import Data.Eq              ( Eq )
import Data.Function        ( ($) )
import Data.Functor         ( fmap )
import Data.List            ( dropWhile, filter, foldr1, isPrefixOf, init, inits
                            , last, replicate, tails, zipWith )
import Data.List.NonEmpty   ( NonEmpty( (:|) ), nub )
import Data.Maybe           ( fromMaybe, maybe )
import Data.Ord             ( Ord )
import Data.String          ( String, unlines )
import Data.Foldable        ( foldl1, toList )
import Data.Traversable     ( Traversable )
import Data.Tuple           ( fst )
import System.Exit          ( ExitCode )
import System.IO            ( IO )
import Text.Read            ( Read, read, readEither )
import Text.Show            ( show )

-- base-unicode-symbols ----------------

import Data.Eq.Unicode          ( (‚â°) )
import Data.Function.Unicode    ( (‚àò) )
import Data.Monoid.Unicode      ( (‚äï) )
import Numeric.Natural.Unicode  ( ‚Ñï )
import Prelude.Unicode          ( ‚Ñ§ )

-- data-textual ------------------------

import Data.Textual  ( Printable, toString )

-- mono-traversable --------------------

import Data.MonoTraversable  ( Element )

-- more-unicode ------------------------

import Data.MoreUnicode.Applicative  ( (‚äµ), (‚ã™), (‚ã´), (‚à§) )
import Data.MoreUnicode.Char         ( ‚ÑÇ )
import Data.MoreUnicode.Either       ( ùîº, pattern ùï∑, pattern ùïΩ )
import Data.MoreUnicode.Functor      ( (‚ä≥) )
import Data.MoreUnicode.Maybe        ( ùïÑ )
import Data.MoreUnicode.Monad        ( (‚â´) )
import Data.MoreUnicode.String       ( ùïä )

-- mtl -----------------------

import Control.Monad.Except  ( MonadError, throwError )

-- natural -----------------------------

import Natural  ( length )

-- nonempty-containers -----------------

import qualified Data.Set.NonEmpty  as  NonEmptySet
import Data.Set.NonEmpty  ( NESet )

-- non-empty-containers ----------------

import NonEmptyContainers.SeqNE             ( (‚ãó), pattern (:‚´∏) )
import NonEmptyContainers.SeqNEConversions  ( ToSeqNonEmpty( toSeqNE ) )

-- parsec ------------------------------

import Text.Parsec        ( ParseError, SourceName )
import Text.Parsec.Prim   ( Parsec, parse )

-- parsers ------------------------------

import Text.Parser.Combinators  ( Parsing, between, choice, count, eof, option
                                , sepBy1, some, try )
import Text.Parser.Char         ( CharParsing
                                , anyChar, char, digit, noneOf, oneOf )
import Text.Parser.Combinators  ( (<?>), skipOptional, unexpected )

-- tasty -------------------------------

import Test.Tasty  ( TestName, TestTree, testGroup )

-- tasty-hunit -------------------------

import Test.Tasty.HUnit  ( (@=?), testCase )

-- tasty-plus --------------------------

import TastyPlus  ( assertIsLeft, assertLeft, assertRight, runTestsP
                  , runTestsReplay, runTestTree )

--------------------------------------------------------------------------------

{- | `try` the first thing, then the next thing, until the last thing (which
     isn't surrounded by a `try`) -}

tries ‚à∑ (ToSeqNonEmpty œà, Parsing Œ∑, Element œà ~ Œ∑ Œ±) ‚áí œà ‚Üí Œ∑ Œ±
tries xs = case toSeqNE xs of
             ts :‚´∏ t ‚Üí foldl1 (‚à§) (toList ((try ‚ä≥ ts) ‚ãó t))

----------------------------------------

{- | UTF Byte-Order-Mark, may be seen as the first character of UTF8 files
     https://en.wikipedia.org/wiki/Byte_order_mark -}
utf8BOM ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ‚ÑÇ
utf8BOM = char '\65279'

----------------------------------------

{- | `Text.Parser.Char.spaces` parses *all* spaces, including newline.
     This function skips non-newline whitespaces.
 -}
whitespaces ‚à∑ CharParsing Œ∑ ‚áí Œ∑ String
whitespaces = many $ oneOf " \t"

----------------------------------------

{- | Parse a newline, optionally preceded by a carriage-return.  Because of
     windoze. -}
nl ‚à∑ (CharParsing Œ∑, Monad Œ∑) ‚áí Œ∑ ()
nl = skipOptional (char '\r') ‚ã´ char '\n' ‚ã´ return () <?> "cr/nl"

----------------------------------------

choices ‚à∑ [Œ±] ‚Üí [(Œ±, [Œ±])]
choices xs = zipWith (\ begin (chosen, end) ‚Üí (chosen, begin ‚äï end))
                     -- though init is notionally unsafe, tails always produces
                     -- a non-empty list (tails [] ‚â° [[]]), so init is safe
                     -- in this instance
                     (inits xs) ((\ (a:as) ‚Üí (a,as)) ‚ä≥ init (tails xs))

choicesTests ‚à∑ TestTree
choicesTests =
  testGroup "choices"
      [ testCase "123" $ [(1,[2,3]),(2,[1,3]),(3,[1,2])] @=? choices [1,2,3‚à∑‚Ñï] ]

----------------------------------------

{- | Given a list of parsers, generate a parser that will allow each parser up
     to once in any order.  E.g., many1choice [string "a", string "b"] will
     parse "", "a", "ab", "ba", "b".  We try to be parsimonious about how we do
     that (we don't just generate the cartesian product of possible parses, to
     avoid exponential back-tracking).

     Note that you can allow specific repeat counts simply by repeating the
     parser; thus many1choice [string "a", string "a", "string "b"] will parse
     "", "a", "b", "aa", "ab", "ba", "aab", "aba", "baa"

     Note also that to avoid backtracking cost, each individual parser is not
     automatically wrapped in a try.  That means that
     many1choice [string "bar", string "baz"]
     will not parse "baz", because the "bar" will consume the "ba" before
     failing.  Thus, if you wish to supply some parsers with common prefices,
     you should wrap those parsers in a try
-}

many1choice ‚à∑ (Monad Œ∑, Alternative Œ∑) ‚áí [Œ∑ Œ±] ‚Üí Œ∑ [Œ±]
many1choice [] = count 0 $ choice []
many1choice xs = option [] ‚àò choice $ many1choice' ‚ä≥ choices xs
-- kept at the top level, rather than in a where, so we get the benefit of
-- memoization
many1choice' ‚à∑ (Monad Œ∑, Alternative Œ∑) ‚áí (Œ∑ Œ±, [Œ∑ Œ±]) ‚Üí Œ∑ [Œ±]
many1choice' (x,xs) = liftM2 (:) x (many1choice xs)

many1choiceTests ‚à∑ TestTree
many1choiceTests =
  let
    aab ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ ùïä
    aab = many1choice [char 'a', char 'a', char 'b'] ‚ã™ eof


    testAAB s = testCase s $ ùïΩ s @=? parse aab s s
    testAAB_E s = testCase s $ assertIsLeft (parse aab s s)
   in
    testGroup "many1choice"
              [ testAAB "a"
              , testAAB "b"
              , testAAB "ab"
              , testAAB "ba"
              , testAAB "aa"
              , testAAB "aab"
              , testAAB "aba"
              , testAAB "baa"
              , testAAB "baa"
              , testAAB_E "bb"
              , testAAB_E "bba"
              , testAAB_E "bab"
              , testAAB_E "bba"
              ]

----------------------------------------

{- | Parse between two characters -}
betweenCs ‚à∑ CharParsing Œ∑ ‚áí ‚ÑÇ ‚Üí ‚ÑÇ ‚Üí Œ∑ Œ± ‚Üí Œ∑ Œ±
betweenCs l r = between (char l) (char r)

----------------------------------------

{- | Parse between parentheses -}
parens ‚à∑ CharParsing Œ∑ ‚áí Œ∑ Œ± ‚Üí Œ∑ Œ±
parens = between (char '(') (char ')')

----------------------------------------

{- | Parse between brackets -}
brackets ‚à∑ CharParsing Œ∑ ‚áí Œ∑ Œ± ‚Üí Œ∑ Œ±
brackets = between (char '[') (char ']')

----------------------------------------

{- | Parse between brackets -}
braces ‚à∑ CharParsing Œ∑ ‚áí Œ∑ Œ± ‚Üí Œ∑ Œ±
braces = between (char '{') (char '}')

----------------------------------------

{- | Parse 1 or more digits -}
digits ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ùïä
digits = some digit

----------------------------------------

{- | Parse any character except those in `cs`; they must be doubled.  Thus

     @ parse (many (try $ doubledChar "{}")) "test" "o}}{{p}" ‚â° Right "o}{p" @

     Note the use of `try`; doubleChar will consume the first char of
     non-conformant input.
 -}
doubledChar ‚à∑ CharParsing Œ∑ ‚áí [‚ÑÇ] ‚Üí Œ∑ ‚ÑÇ
doubledChar cs = (choice $ (\ c ‚Üí char c ‚ã´ char c) ‚ä≥ cs) ‚à§ noneOf cs

----------------------------------------

{- | Parse many characters, most directly, but those in `cs` must be doubled up.

     @ parse (doubledChars "{}") "test" "o}}{{p}x" ‚â° Right "o}{p" @
 -}
doubledChars ‚à∑ CharParsing Œ∑ ‚áí [‚ÑÇ] ‚Üí Œ∑ ùïä
doubledChars cs = many (try $ doubledChar cs)

----------------------------------------

{- | Parse many characters, most directly, bounded by `l` on the left and `r`
     on the right; instances of `l` & `r` within the text must be doubled up.

     @ parse (boundedDoubledChars '{' '}') "test" "{o}}{{p}x" ‚â° Right "o}{p" @

     @ parse (boundedDoubledChars '!' '!') "test" "!o}}!!p!" ‚â° Right "o}}!p" @
 -}
boundedDoubledChars ‚à∑ CharParsing Œ∑ ‚áí ‚ÑÇ ‚Üí ‚ÑÇ ‚Üí Œ∑ ùïä
boundedDoubledChars l r = betweenCs l r (doubledChars [l,r])

----------------------------------------

{- | Parse a uniquely matching prefix.

     Given a value table, and a parser; can we parse to something that uniquely
     provides a result?  The parser succeeds if the parse output prefixes
     precisely one result.
 -}
uniquePrefix ‚à∑ (MonadFail Œ∑, Eq Œ±, Printable œá) ‚áí
               [([Œ±],Œ≤)] ‚Üí ([Œ±] ‚Üí œá) ‚Üí Œ∑ [Œ±] ‚Üí Œ∑ Œ≤
uniquePrefix ss e prs = do
  s ‚Üê prs
  case filter ((s `isPrefixOf`) ‚àò fst) ss of
    [(_,y)] ‚Üí return y
    _       ‚Üí fail $ toString (e s)

----------------------------------------

{- | Parse the given character, or the same character in another case
     (upper or lower). -}
caseInsensitiveChar ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí ‚ÑÇ ‚Üí Œ∑ ‚ÑÇ
caseInsensitiveChar c = do
  _ ‚Üê char (toLower c) ‚à§ char (toUpper c)
  return c

--------------------

{- | Parse the given string, but with any combination of upper and lower case
     characters. -}
caseInsensitiveString ‚à∑ (Monad Œ∑, CharParsing Œ∑, Traversable œÜ) ‚áí œÜ ‚ÑÇ ‚Üí Œ∑ (œÜ ‚ÑÇ)
caseInsensitiveString = sequence ‚àò fmap caseInsensitiveChar

--------------------------------------

{- | Parse a NonEmpty list of things with a separator; like `sepBy1`, but more
     strongly typed. -}
sepByNE ‚à∑ Alternative Œ≥ ‚áí Œ≥ Œ± ‚Üí Œ≥ œÉ ‚Üí Œ≥ (NonEmpty Œ±)
sepByNE x s = NonEmptyList.fromList ‚ä≥ sepBy1 x s

--------------------------------------

{- | Parse a comma-separated non-empty set of values, given a value parser. -}
commaList ‚à∑ ‚àÄ Œ± œÅ . (Ord Œ±, CharParsing œÅ) ‚áí œÅ Œ± ‚Üí œÅ (NonEmpty Œ±)
commaList p = sepByNE p (char ',')

--------------------

commaListTests ‚à∑ TestTree
commaListTests =
  let parse' = parse @ùïä @_ @(NonEmpty Int)
   in testGroup "commaList"
                [ let (t,e) = ("123,45,6", 123 :| [45, 6])
                   in testCase t $
                        ùïΩ e @=? parse' (commaList (read ‚ä≥ some digit)) t t
                ]

----------------------------------------

{- | Parse a comma-separated non-empty set of values, given a value parser.
     A `String` error is thrown if duplicates are detected. -}
commaSet ‚à∑ ‚àÄ Œ± Œ∑ . (Ord Œ±, MonadError ùïä Œ∑) ‚áí
           SourceName ‚Üí Parsec ùïä () Œ± ‚Üí ùïä ‚Üí Œ∑ (NESet Œ±)
commaSet nm p s =
  case parse (commaList p) nm s of
    ùï∑ e ‚Üí throwError (show e)
    ùïΩ xs ‚Üí if xs ‚â° nub xs
           then return $ NonEmptySet.fromList xs
           else throwError $ "Duplicates detected in input '" ‚äï s ‚äï "'"

--------------------

commaSetTests ‚à∑ TestTree
commaSetTests =
  testGroup "commaSet"
            [ let t = "1,23,456"
                  e = NonEmptySet.fromList (1 :| [23,456‚à∑‚Ñ§])
               in testCase t $
                    assertRight (e @=?) (commaSet t (read ‚ä≥ some digit) t)
            , let t = "1,23,23"
                  e = "Duplicates detected in input '" ‚äï t ‚äï "'"
               in testCase t $
                    assertLeft (e @=?)
                               (commaSet t (read @Int ‚ä≥ some digit) t)
            ]

----------------------------------------

{- Parse one or two characters, given a character parser. -}
parse1_2 ‚à∑ CharParsing œà ‚áí œà ‚ÑÇ ‚Üí œà ùïä
parse1_2 p = (:) ‚ä≥ p ‚äµ (maybe "" pure ‚ä≥ optional p)

----------

parse1_2Tests ‚à∑ TestTree
parse1_2Tests = testGroup "parse1_2" $
  let
    check ‚à∑ ùïä ‚Üí TestTree
    check x = testCase x $
      assertRight (x @=?) $ parse (parse1_2 anyChar ‚ã™ eof) x x
    checkFail ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    checkFail x e =
      testCase x $ assertLeft (e @=?) $
        first show $ parse (parse1_2 anyChar ‚ã™ eof) x x
  in
    [ check "x"
    , check "xy"
    , checkFail "" "(line 1, column 1):\nunexpected end of input"
    , checkFail "xyz" (init $ unlines [ "\"xyz\" (line 1, column 3):"
                                      , "unexpected 'z'"
                                      , "expecting end of input"
                                      ])
    ]

--------------------

{- | Parse one or two digits. -}
parse1_2digits ‚à∑ CharParsing œà ‚áí œà ùïä
parse1_2digits = parse1_2 digit

----------

parse1_2digitsTests ‚à∑ TestTree
parse1_2digitsTests = testGroup "parse1_2digits" $
  let
    check ‚à∑ ùïä ‚Üí TestTree
    check x = testCase x $ assertRight (x @=?) $ parse parse1_2digits x x
    checkFail ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    checkFail x e =
      testCase x $ assertLeft (e @=?) $
        first show $ parse parse1_2digits x x
  in
    [ check "1"
    , check "23"
    , checkFail ""
                "(line 1, column 1):\nunexpected end of input\nexpecting digit"
    , checkFail "x" (init $ unlines [ "\"x\" (line 1, column 1):"
                                      , "unexpected \"x\""
                                      , "expecting digit"
                                      ])
    ]

--------------------

{- | Parse a decimal value, with up to 2 digits, with up to two decimal
     places.  Input with no decimal point are allowed, as is input with a
     trailing decimal point.
 -}
parseDecimal2_1 ‚à∑ Read Œ± ‚áí CharParsing œà ‚áí œà Œ±
parseDecimal2_1 =
   let
     cat ‚à∑ ùïÑ ‚ÑÇ ‚Üí ùïä
     -- This is for the post-decimal-point bit; if there's nothing (e.g.,
     -- '76.'; we add a 0 to make it '76.0' so that `read` parses correctly.
     -- We do this only for the right-most digit, lest we accidentally insert a
     -- digit ahead of a non-zero digit and thus change value.
     cat a = maybe "0" pure a
     cat' ‚à∑ ùïä ‚Üí ùïÑ ùïä ‚Üí ùïä
     cat' a b = a ‚äï "." ‚äï fromMaybe "0" b
     -- parse a group with leading digits (X, XX, XX., XX.Y)
     p_leading = cat' ‚ä≥ parse1_2digits
                      ‚äµ optional (cat ‚ä≥ (char '.' ‚ã´ optional digit))
     -- parse a group with no leading digits (.Y)
     p_no_lead = (‚äï) ‚ä≥ pure "0." ‚äµ (char '.' ‚ã´ (pure ‚ä≥ digit))
   in
     read ‚ä≥ (p_leading ‚à§ p_no_lead)

----------

parseDecimal2_1Tests ‚à∑ TestTree
parseDecimal2_1Tests = testGroup "parseDecimal2_1" $
  let
    check ‚à∑ ùïä ‚Üí Double ‚Üí TestTree
    check x d = testCase x $
      assertRight (d @=?) $ parse (parseDecimal2_1 ‚ã™ eof) x x
    checkFail ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    checkFail x e =
      testCase x $ assertLeft (e @=?) $
        first show $ parse @_ @_ @Double (parseDecimal2_1 ‚ã™ eof) x x
    unl = init ‚àò unlines
  in
    [ check  ".1"    0.1
    , check  "1"     1.0
    , check  "1."    1.0
    , check  "1.0"   1.0
    , check  "1.1"   1.1
    , check "11"    11.0
    , check "11."   11.0
    , check "11.0"  11.0
    , check "11.1"  11.1
    , checkFail "" (unl [ "(line 1, column 1):"
                        , "unexpected end of input"
                        , "expecting digit or \".\""
                        ])
    , checkFail "x" (unl [ "\"x\" (line 1, column 1):"
                         , "unexpected \"x\""
                         , "expecting digit or \".\""
                         ])
    , checkFail "123" (unl [ "\"123\" (line 1, column 3):"
                           , "unexpected '3'"
                           , "expecting \".\" or end of input"
                           ])
    , checkFail "1.23" (unl [ "\"1.23\" (line 1, column 4):"
                            , "unexpected '3'"
                            , "expecting end of input"
                            ])
    ]

--------------------

{- | Parse a Float, one or two digits (pre-decimal), with up to two decimal
     places. -}
parseFloat2_1 ‚à∑ CharParsing œà ‚áí œà Float
parseFloat2_1 = parseDecimal2_1

----------

parseFloat2_1Tests ‚à∑ TestTree
parseFloat2_1Tests = testGroup "parseFloat2_1" $
  let
    check ‚à∑ ùïä ‚Üí Float ‚Üí TestTree
    check x d = testCase x $
      assertRight (d @=?) $ parse (parseFloat2_1 ‚ã™ eof) x x
    checkFail ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    checkFail x e =
      testCase x $ assertLeft (e @=?) $
        first show $ parse (parseFloat2_1 ‚ã™ eof) x x
    unl = init ‚àò unlines
  in
    [ check  ".1"    0.1
    , check  "1"     1.0
    , check  "1."    1.0
    , check  "1.0"   1.0
    , check  "1.1"   1.1
    , check "11"    11.0
    , check "11."   11.0
    , check "11.0"  11.0
    , check "11.1"  11.1
    , checkFail "" (unl [ "(line 1, column 1):"
                        , "unexpected end of input"
                        , "expecting digit or \".\""
                        ])
    , checkFail "x" (unl [ "\"x\" (line 1, column 1):"
                         , "unexpected \"x\""
                         , "expecting digit or \".\""
                         ])
    , checkFail "123" (unl [ "\"123\" (line 1, column 3):"
                           , "unexpected '3'"
                           , "expecting \".\" or end of input"
                           ])
    , checkFail "1.23" (unl [ "\"1.23\" (line 1, column 4):"
                            , "unexpected '3'"
                            , "expecting end of input"
                            ])
    ]

----------------------------------------

{- | Given a parser (of Œ±), and a checked conversion (from Œ± ‚Üí Œ≤, or a ùïä error);
     build a parser for Œ≤. -}
convertParser ‚à∑ ‚àÄ Œ± Œ≤ Œ∑ . (Monad Œ∑, Parsing Œ∑) ‚áí
                (Œ± ‚Üí ùîº ùïä Œ≤) ‚Üí Œ∑ (ùîº ùïä Œ±) ‚Üí Œ∑ Œ≤
convertParser f p = p ‚â´ either unexpected (either unexpected return ‚àò f)

--------------------

{- | Given a parser (of ùïä), and a checked conversion (from Œ± ‚Üí Œ≤, where Œ± is an
     instance of `Read`); build a parser for Œ≤. -}
convertReadParser ‚à∑ ‚àÄ Œ± Œ≤ Œ∑ . (Monad Œ∑, CharParsing Œ∑, Read Œ±) ‚áí
                    (Œ± ‚Üí ùîº ùïä Œ≤) ‚Üí Œ∑ ùïä ‚Üí Œ∑ Œ≤
convertReadParser f p = convertParser f (readEither ‚ä≥ p)

----------------------------------------

{-
eChar ‚à∑ Char
eChar = '\\'

escape :: Parser String
escape = pure ‚ä≥ oneOf "\\\"0nrvtbf{}"

nonEscape :: Parser Char
nonEscape = noneOf "\\\"\0\n\r\v\t\b\f{}"

character :: Parser String
character = fmap return nonEscape <|> escape

parseEscaped ‚à∑ String ‚Üí String ‚Üí Parser String
parseEscaped l r = do
    strings <- string l *> many character <* string r
    return $ concat strings
-}

----------------------------------------

{- | A parser `p` repeated between `m` & `n` times.  You almost certainly
     want to follow this with something that p would not match. -}
counts ‚à∑ (Alternative œÜ, Parsing œÜ) ‚áí ‚Ñï ‚Üí ‚Ñï ‚Üí œÜ Œ± ‚Üí œÜ [Œ±]
counts m n p = case [n,n-1..m] of
                 []     ‚Üí pure []
                 (x:xs) ‚Üí tries $ (\ i ‚Üí count (fromIntegral i) p) ‚ä≥ x:|xs

----------------------------------------


{- | Parse between `m` & `n` consecutive digits, right-padding to `n` digits
     with a '0' char.  E.g., for parsing after a decimal point. -}
ndigits ‚à∑ ‚àÄ Œ± œÜ . (Num Œ±, Read Œ±, CharParsing œÜ) ‚áí ‚Ñï ‚Üí ‚Ñï ‚Üí œÜ Œ±
ndigits m n = (\ x -> case x of "" -> 0; _ -> read x) ‚ä≥ (counts m n digit)

{- | Parse between `m` & `n` consecutive digits, right-padding to `n` digits
     with a '0' char.  E.g., for parsing after a decimal point. -}
ndigitsPadR ‚à∑ CharParsing œÜ ‚áí ‚Ñï ‚Üí ‚Ñï ‚Üí œÜ ùïä
ndigitsPadR m n =
  (padR n '0' ‚àò show @‚Ñï) ‚ä≥ ndigits m n
  where len s = fromIntegral $ length s
        -- we use integer arithmetic here, rather than natural, so that if
        -- (n - len s) were to be negative; replicate gives an empty list rather
        -- than a type error
        padR i c s = s ‚äï replicate (fromIntegral @_ @Int i - len s) c

----------------------------------------

{- | Parse up to `n` digits after a decimal point; returns the digits.  Pads
     out the digits (on the right) with '0's.  If there is no decimal point,
     a string of `n` '0's is returned.  This is to provide a consistent number
     of post-decimal-point numbers, where the user can specify up to `n` digits.
 -}
nDecimalDigits ‚à∑ CharParsing œÜ ‚áí ‚Ñï ‚Üí œÜ ùïä
nDecimalDigits n = char '.' ‚ã´ ndigitsPadR 0 (fromIntegral n)

----------

nDecimalDigitsTests ‚à∑ TestTree
nDecimalDigitsTests = testGroup "nDecimalDigits" $
  let
    check ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    check x d = testCase x $
      assertRight (d @=?) $ parse (nDecimalDigits 3 ‚ã™ eof) x x
    checkFail ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    checkFail x e =
      testCase x $ assertLeft (e @=?) $
        first show $ parse (nDecimalDigits 3 ‚ã™ eof) x x
    unl = init ‚àò unlines
  in
    [ check  ".1"    "100"
    , check  "."     "000"
    , check  ".123"  "123"
    , checkFail ".1234" (unl [ "\".1234\" (line 1, column 5):"
                             , "unexpected '4'"
                             , "expecting end of input"
                             ])
    , checkFail "" (unl [ "(line 1, column 1):"
                        , "unexpected end of input"
                        , "expecting \".\""
                        ])
    ]

----------------------------------------

{- | Like `nDecimalDigits`; but will accept an empty string (no leading '.'),
     which will be "parsed" as a string of '0's.
 -}
nDecimalDigits' ‚à∑ CharParsing œÜ ‚áí ‚Ñï ‚Üí œÜ ùïä
nDecimalDigits' n =
  fromMaybe (replicate (fromIntegral n) '0') ‚ä≥ optional (nDecimalDigits n)

----------

nDecimalDigits'Tests ‚à∑ TestTree
nDecimalDigits'Tests = testGroup "nDecimalDigits'" $
  let
    check ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    check x d = testCase x $
      assertRight (d @=?) $ parse (nDecimalDigits' 3 ‚ã™ eof) x x
    checkFail ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    checkFail x e =
      testCase x $ assertLeft (e @=?) $
        first show $ parse (nDecimalDigits' 3 ‚ã™ eof) x x
    unl = init ‚àò unlines
  in
    [ check  ".1"    "100"
    , check  "."     "000"
    , check  ""      "000"
    , check  ".123"  "123"
    , checkFail ".1234" (unl [ "\".1234\" (line 1, column 5):"
                             , "unexpected '4'"
                             , "expecting end of input"
                             ])
    ]

----------------------------------------

{- | Parse a decimal value, with an optional decimal point and up to `n` digits
     after.  The result is returned as a string, which is effectively the int
     multiplied by 10^n; thus, a string "10.23" is returned as "1023".

     If fewer than `n` digits are supplied after the decimal point, the
     "missing" digits are filled in with zeros; thus `nDecimal 3` when parsing
     "10.2" will return "10200".

     Leading zeroes with in the result will be dropped; hence `nDecimal 3` when
     parsing "0.1" will return "100".

     Note that this will not successfully parse an empty string; but a lone
     decimal point will parse as "0"
 -}
nDecimal ‚à∑ CharParsing œÜ ‚áí ‚Ñï ‚Üí œÜ ùïä
nDecimal n =
  let zeroes = replicate (fromIntegral n) '0'
      dropWhileInit p xs = dropWhile p (init xs) ‚äï [last xs]
   in dropWhileInit (‚â° '0') ‚ä≥ (tries $ ((‚äï) ‚ä≥ many digit ‚äµ nDecimalDigits n)
                                    :| [ (‚äï) ‚ä≥ some digit ‚äµ pure zeroes ] )

----------

nDecimalTests ‚à∑ TestTree
nDecimalTests = testGroup "nDecimal" $
  let
    check ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    check x d = testCase x $
      assertRight (d @=?) $ parse (nDecimal 3 ‚ã™ eof) x x
    checkFail ‚à∑ ùïä ‚Üí ùïä ‚Üí TestTree
    checkFail x e =
      testCase x $ assertLeft (e @=?) $
        first show $ parse (nDecimal 3 ‚ã™ eof) x x
    unl = init ‚àò unlines
  in
    [ check  "0.1"    "100"
    , check  "1"     "1000"
    , check  ".1"     "100"
    , check  "."        "0"
    , check  "0"        "0"
    , check  "1.234" "1234"
    , checkFail  ""         (unl [ "(line 1, column 1):"
                                 , "unexpected end of input"
                                 , "expecting digit or \".\""
                                 ])
    , checkFail "1.2345678" (unl [ "\"1.2345678\" (line 1, column 6):"
                                 , "unexpected '5'"
                                 , "expecting end of input"
                                 ])
    ]

----------------------------------------

{- | Parse a milli- value, given as a decimal number of seconds with up to 3
     digits after an (optional) decimal point.  -}

parseMillis ‚à∑ CharParsing œÜ ‚áí œÜ ùïä
parseMillis = nDecimal 3

----------------------------------------

{- | Parse a micro- value, given as a decimal number of seconds with up to 6
     digits after an (optional) decimal point.  -}

parseMicros ‚à∑ CharParsing œÜ ‚áí œÜ ùïä
parseMicros = nDecimal 6

----------------------------------------

{- | Parse a single char from a string, which must be a backslashed double-quote,
     t (tab), n (newline) or backslash. -}
parseBackslashedChar ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ‚ÑÇ

parseBackslashedChar = char '\\' ‚ã´ foldr1 (‚à§) [ char '\\' ‚ã´ pure '\\'
                                              , char 't'  ‚ã´ pure '\t'
                                              , char 'n'  ‚ã´ pure '\n'
                                              , char '"'  ‚ã´ pure '"'
                                              ]

----------

parseBackslashedCharTests ‚à∑ TestTree
parseBackslashedCharTests =
  let prse           ‚à∑ ùïä ‚Üí ùîº ParseError ‚ÑÇ
      prse s         = parse parseBackslashedChar s s
      check          ‚à∑ TestName ‚Üí ‚ÑÇ ‚Üí ùïä ‚Üí TestTree
      check nm c s   = testCase nm $ assertRight (c @=?) (prse s)
      checkFail      ‚à∑ TestName ‚Üí ùïä ‚Üí TestTree
      checkFail nm s = testCase nm $ assertIsLeft (prse s)
   in testGroup "parseBackslashedChar"
    [ check "newline" '\n' "\\n"
    , check "tab"     '\t' "\\t"
    , check "\\"      '\\' "\\\\"
    , checkFail "a" "\\a"
    , checkFail "\\t" "\t"
    ]

----------------------------------------

{- | Parse a double-quoted string.  Within that string, actual newlines & tabs
     are forbidden: slashes & double-quotes must be backslashed, and newlines
     are '\n', tabs are '\t'.
 -}
dQuotedString ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ùïä
dQuotedString = char '"' ‚ã´ inner ‚ã™ char '"'
                where inner =  many (parseBackslashedChar ‚à§ noneOf "\"\\\n\t")

--------------------

dQuotedStringTests ‚à∑ TestTree
dQuotedStringTests =
  let prse           ‚à∑ ùïä ‚Üí ùîº ParseError ùïä
      prse s         = parse dQuotedString s s
      check          ‚à∑ TestName ‚Üí ùïä ‚Üí ùïä ‚Üí TestTree
      check nm c s   = testCase nm $ assertRight (c @=?) (prse s)
      checkFail      ‚à∑ TestName ‚Üí ùïä ‚Üí TestTree
      checkFail nm s = testCase nm $ assertIsLeft (prse s)
   in testGroup "dQuotedString"
    [ check "newline" "\n"  "\"\\n\""
    , check "tab"     "\t"  "\"\\t\""
    , check "\\"      "\\"  "\"\\\\\""
    , check "bob"     "bob" "\"bob\""
    , check "empty"   ""    "\"\""
    , checkFail "a" "\\a"
    , checkFail "\"a" "\"a"
    , checkFail "a\"" "a\""
    , checkFail "\\t" "\t"
    ]

----------------------------------------

{- | Either a double-quoted string (see `dQuotedString`) or else an unquoted
     string, with no newlines, tabs or spaces (and not starting with a
     double-quote).
-}
stringMaybeDQuoted ‚à∑ CharParsing Œ∑ ‚áí Œ∑ ùïä
stringMaybeDQuoted =
  dQuotedString ‚à§ ((:) ‚ä≥ noneOf ("\"\n\t ") ‚äµ many (noneOf "\n\t "))

--------------------

stringMaybeDQuotedTests ‚à∑ TestTree
stringMaybeDQuotedTests =
  let prse           ‚à∑ ùïä ‚Üí ùîº ParseError ùïä
      prse s         = parse (stringMaybeDQuoted ‚ã™ eof) s s
      check          ‚à∑ TestName ‚Üí ùïä ‚Üí ùïä ‚Üí TestTree
      check nm c s   = testCase nm $ assertRight (c @=?) (prse s)
      checkFail      ‚à∑ TestName ‚Üí ùïä ‚Üí TestTree
      checkFail nm s = testCase nm $ assertIsLeft (prse s)
   in testGroup "stringMaybeDQuoted"
    [ check "newline"     "\n"  "\"\\n\""
    , check "tab"         "\t"  "\"\\t\""
    , check "\\"          "\\"  "\"\\\\\""
    , check "bob"         "bob" "\"bob\""
    , check "\"bob cat\"" "bob cat" "\"bob cat\""
    , checkFail           "bob" "bob cat"
    , check "foo"         "foo" "foo"
    , check "empty"       ""    "\"\""
    , check "\\a"         "\\a" "\\a"
    , checkFail           "\"a" "\"a"
    , check "a\""         "a\"" "a\""
    , checkFail           "\\t" "\t"
    ]

------------------------------------------------------------
--                         tests                          --
------------------------------------------------------------

tests ‚à∑ TestTree
tests = testGroup "ParserPlus"
                  [ choicesTests, many1choiceTests, commaListTests
                  , commaSetTests, parse1_2Tests, parse1_2digitsTests
                  , parseDecimal2_1Tests, parseFloat2_1Tests
                  , nDecimalDigitsTests, nDecimalDigits'Tests
                  , nDecimalTests, parseBackslashedCharTests, dQuotedStringTests
                  , stringMaybeDQuotedTests
                  ]

--------------------

_test ‚à∑ IO ExitCode
_test = runTestTree tests

--------------------

_tests ‚à∑ ùïä ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ ùïä ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
